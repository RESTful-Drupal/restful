<?php

/**
 * @file
 * Turn Drupal to a RESTful server, following best practices.
 */

include_once __DIR__ . '/restful.entity.inc';

use Drupal\Component\Plugin\PluginBase;
use Drupal\restful\Exception\RestfulException;
use Drupal\restful\Exception\ServiceUnavailableException;
use Drupal\restful\Http\HttpHeader;
use Drupal\restful\Http\RequestInterface;
use Drupal\restful\Plugin\resource\CachedResource;
use Drupal\restful\Plugin\resource\RateLimitedResource;
use Drupal\restful\Plugin\resource\ResourceInterface;
use Drupal\restful\RateLimit\RateLimitManager;
use Drupal\restful\RestfulManager;

/**
 * Implements hook_ctools_plugin_directory().
 */
function restful_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
  return NULL;
}

/**
 * Add defaults values to the restful related plugins.
 */
function restful_plugin_process(&$plugin, $info) {
  // Common operations.
  $plugin += array(
    'description' => '',
  );

  // Call the plugin specific process functions.
  $function = array('\RestfulManager', 'pluginProcess' . preg_replace('/ /', '', ucwords(preg_replace('/_/', ' ', $info['type']))));
  if (is_callable($function)) {
    $plugin = call_user_func_array($function, array($plugin, $info));
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function restful_ctools_plugin_type() {
  $plugins['authentication'] = $plugins['restful'] = $plugins['rate_limit'] = $plugins['formatter'] = array(
    'classes' => array('class'),
    'process' => 'restful_plugin_process',
  );
  $plugins['restful']['child plugins'] = TRUE;
  return $plugins;
}


/**
 * Include CTools plugins and get all restful plugins.
 *
 * @return array
 *   All plugins for restful resources.
 */
function restful_get_restful_plugins() {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'restful');
}

/**
 * Include CTools plugins and get all rate_limit plugins.
 *
 * @return array
 *   All the restful rate_limit plugins.
 */
function restful_get_rate_limit_plugins() {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'rate_limit');
}

/**
 * Include CTools plugins and get the specified authentication plugin.
 *
 * @param string $plugin_name
 *   If provided this function only returns the selected plugin.
 *
 * @return array
 *   The selected plugin for restful authentication.
 */
function restful_get_authentication_plugin($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'authentication', $plugin_name);
}

/**
 * Include CTools plugins and get the specified rate_limit plugin.
 *
 * @param string $plugin_name
 *   If provided this function only returns the selected plugin.
 *
 * @return array
 *   The selected plugin for rate limits.
 */
function restful_get_rate_limit_plugin($plugin_name) {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'rate_limit', $plugin_name);
}

/**
 * Implements hook_menu().
 */
function restful_menu() {
  $base_path = variable_get('restful_hook_menu_base_path', 'api');
  $items = array();
  $plugins = restful()
    ->getResourceManager()
    ->getPlugins();
  foreach ($plugins as $plugin) {
    /** @var ResourceInterface $plugin */
    $plugin_definition = $plugin->getPluginDefinition();
    if (!$plugin_definition['hookMenu']) {
      // Plugin explicitly declared no hook menu should be created automatically
      // for it.
      continue;
    }
    $item = array(
      'title' => $plugin_definition['name'],
      'access callback' => 'restful_menu_access_callback',
      'access arguments' => array($plugin_definition['resource']),
      'page callback' => 'restful_menu_process_callback',
      'page arguments' => array($plugin_definition['resource']),
      'delivery callback' => 'restful_formatted_delivery',
      'type' => MENU_CALLBACK,
    );
    // If there is no specific menu item allow the different version variations.
    if ($plugin_definition['hookMenu'] && empty($plugin_definition['menuItem'])) {
      // Add the version string to the arguments.
      $item['access arguments'][] = 1;
      $item['page arguments'][] = 1;
        // Ex: api/v1.2/articles
      $items[$base_path . '/v' . $plugin_definition['majorVersion'] . '.' . $plugin_definition['minorVersion'] . '/' . $plugin_definition['resource']] = $item;
      // Ex: api/v1/articles will use the latest minor version.
      $items[$base_path . '/v' . $plugin_definition['majorVersion'] . '/' . $plugin_definition['resource']] = $item;
      // Ex: api/articles will use the header or the latest version.
      // Do not add the version string to the arguments.
      $item['access arguments'] = $item['page arguments'] = array(1);
      $items[$base_path . '/' . $plugin_definition['resource']] = $item;
    }
    else {
      $items[$plugin_definition['menuItem']] = $item;
    }
  }

  // Make sure the CRSF token endpoint is not HAL.
  if (!empty($items[$base_path . '/session/token'])) {
    $items[$base_path . '/session/token']['delivery callback'] = 'restful_unprepared_delivery';
  }

  // Make sure the Login endpoint has the correct access callback.
  if (!empty($items[$base_path . '/login'])) {
    $items[$base_path . '/login']['access callback'] = 'user_is_anonymous';
  }

  // Add administration page.
  $items['admin/config/services/restful'] = array(
    'title' => 'RESTful',
    'description' => 'Administer the RESTful module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('restful_admin_settings'),
    'access arguments' => array('administer restful'),
    'file' => 'restful.admin.inc',
  );
  $items['admin/config/services/restful/restful'] = $items['admin/config/services/restful'];
  $items['admin/config/services/restful/restful']['type'] = MENU_DEFAULT_LOCAL_TASK;

  return $items;
}

/**
 *  Implements hook_permission().
 */
function restful_permission() {
  return array(
    'administer restful' => array(
      'title' => t('Administer the RESTful module'),
      'description' => t('Access the administration pages for the RESTful module.'),
    ),
  );
}

/**
 *  Implements hook_help().
 */
function restful_help($path, $arg) {
  switch ($path) {
    case 'admin/structure/block':
    case 'admin/help#restful':
      return '<p>' . t('This module is managed in GitHub. Please make sure to read the docs in the !link page for more help.', array(
        '!link' => l('README.md', 'https://github.com/Gizra/restful/blob/7.x-1.x/README.md'),
      )) . '</p>';
  }
}

/**
 * Get the RestfulManager.
 *
 * Calling restful() from anywhere in the code will give you access to the
 * RestfulManager. That in turn will provide you access to all the elements
 * involved.
 *
 * @return RestfulManager
 *   The manager.
 */
function restful() {
  static $manager;
  if (isset($manager)) {
    return $manager;
  }
  try {
    $manager = xautoload()->restfulManager;
  }
  catch (\Exception $e) {
    // During the menu access checks we get here before plug_xautoload has had
    // the chance to include the composer manager classes. That means that we
    // would not be able to get the resource manager that depends on composer
    // classes.
    composer_manager_register_autoloader();
    $manager = RestfulManager::createFromGlobals();
    xautoload()->getServiceContainer()->set('restfulManager', $manager);
  }
  return $manager;
}

/**
 * Access callback; Determine access for an API call.
 *
 * @param string $resource_name
 *   The name of the resource (e.g. "articles").
 *
 * @param $version_string
 *   The version array.
 *
 * @return bool
 *   TRUE if user is allowed to access resource.
 */
function restful_menu_access_callback($resource_name, $version_string = NULL) {
  $resource_manager = restful()->getResourceManager();
  if (!empty($version_string) && preg_match('/v[0-9]+(\.[0-9]+)?/', $version_string)) {
    $version_string = substr($version_string, 1);
    $parsed_versions = explode('.', $version_string);
    if (count($parsed_versions) == 2) {
      // If there is only the major we need to get the version from the request,
      // to get the latest version within the major version.
      $versions = $parsed_versions;
    }
  }
  if (empty($versions) && !$versions = $resource_manager->getVersionFromRequest()) {
    // No version could be found.
    return FALSE;
  }

  try {
    return $resource_manager
      ->getPlugin($resource_name . PluginBase::DERIVATIVE_SEPARATOR . implode('.', $versions), restful()->getRequest())
      ->access();
  }
  catch (RestfulException $e) {
    // We can get here if the request method is not valid or if no resource can
    // be negotiated.
    return FALSE;
  }
}

/**
 * Page callback; Return the response for an API call.
 *
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 * @param $version
 *   The version, prefixed with v (e.g. v1, v2.2).
 *
 * @throws ServiceUnavailableException
 *
 * @return string
 *   JSON output with the result of the API call.
 *
 * @see http://tools.ietf.org/html/draft-nottingham-http-problem-06
 */
function restful_menu_process_callback($resource_name, $version = NULL) {
  $path = func_get_args();
  array_shift($path);
  if (preg_match('/^v\d+(\.\d+)?$/', $version)) {
    array_shift($path);
  }
  $resource_manager = restful()->getResourceManager();
  list($major_version, $minor_version) = $resource_manager->getVersionFromRequest();
  $request = restful()->getRequest();
  $request->setViaRouter(TRUE);
  $resource = $resource_manager->getPlugin($resource_name . PluginBase::DERIVATIVE_SEPARATOR . $major_version . '.' . $minor_version, $request);

  // Vary the response with the presence of the X-API-Version or Accept headers.
  $vary = $request
    ->getHeaders()
    ->get('Vary')
    ->getValueString() ?: '';
  $additional_variations = array($vary, 'Accept');
  if ($x_api_version = $request
    ->getHeaders()
    ->get('X-API-Version')
    ->getValueString()) {
    $additional_variations[] = 'X-API-Version';
  }
  if ($additional_variations) {
    restful()
      ->getResponse()
      ->getHeaders()
      ->append(HttpHeader::create('Vary', implode(',', $additional_variations)));
  }

  // Always add the allow origin if configured.
  $plugin_definition = $resource->getPluginDefinition();
  if (!empty($plugin_definition['allowOrigin'])) {
    restful()
      ->getResponse()
      ->getHeaders()
      ->append(HttpHeader::create('Access-Control-Allow-Origin', $plugin_definition['allowOrigin']));
  }

  try {
    $resource->setPath(implode('/', $path));
    return $resource->process();
  }
  catch (RestfulException $e) {
    $result = array(
      'type' => $e->getType(),
      'title' => $e->getMessage(),
      'status' => $e->getCode(),
      'detail' => $e->getDescription(),
    );

    if ($instance = $e->getInstance()) {
      $result['instance'] = $instance;
    }

    if ($errors = $e->getFieldErrors()) {
      $result['errors'] = $errors;
    }

    foreach ($e->getHeaders() as $header_name => $header_value) {
      drupal_add_http_header($header_name, $header_value);
    }
  }
  catch (Exception $e) {
    $result = array(
      'type' => 'http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1',
      'title' => $e->getMessage(),
      'status' => 500,
    );
  }

  // Adhere to the API Problem draft proposal.
  drupal_add_http_header('Status', $result['status']);
  drupal_add_http_header('Content-Type', 'application/problem+json; charset=utf-8');
  return $result;
}

/**
 * Returns data in JSON format.
 *
 * We do not use drupal_json_output(), in order to maintain the "Content-Type"
 * header.
 *
 * @param mixed $var
 *   (optional) If set, the variable will be converted to JSON and output.
 * @param string $method
 *   Name of the method for the formatter.
 *
 * @see restful_menu_process_callback()
 */
function restful_delivery($var = NULL, $method = 'format') {
  if (!isset($var)) {
    return;
  }

  $request = restful()->getRequest();
  $response = restful()->getResponse();
  if (is_int($var)) {
    _restful_get_data_from_menu_status($var);

    // Adhere to the API Problem draft proposal.
    $formatter_id = variable_get('restful_default_output_formatter', 'json');
    // Get the data in the default output format.
    $data = restful()
      ->getFormatterManager()
      ->negotiateFormatter(NULL, $formatter_id)
      ->format($var);

    $response->setStatusCode($var['status']);
    $response->getHeaders()->add(HttpHeader::create('Content-Type', 'application/problem+' . $formatter_id . '; charset=utf-8'));
    $response->setContent($data);
    $response->prepare($request);
    $response->send();
    return;
  }

  // If we are returning from an OPTIONS call, always use render.
  if ($request->getMethod() == RequestInterface::METHOD_OPTIONS) {
    $method = 'render';
  }

  try {
    // Get the formatter for the current resource.
    $resource = restful()
      ->getResourceManager()
      ->negotiate($request);
    // Get a new formatter manager.
    $formatter_manager = restful()
      ->getFormatterManager();
    $formatter_manager->setResource($resource);
    $plugin_definition = $resource->getPluginDefinition();
    $formatter_name = isset($plugin_definition['formatter']) ? $plugin_definition['formatter'] : NULL;
    $output = call_user_func(array($formatter_manager, $method), $var, $formatter_name);
    $response->setContent($output);
  }
  catch (RestfulException $e) {
    // Handle if the formatter does not exist.
    drupal_add_http_header('Status', $e->getCode());
    echo $e->getMessage();
    return;
  }

  $response->prepare($request);
  $response->send();
}

/**
 * Returns data in JSON format using data preparation in the formatter plugin.
 *
 * @param $var
 *   (optional) If set, the variable will be converted to JSON and output.
 *
 * @see restful_menu_process_callback()
 */
function restful_formatted_delivery($var = NULL) {
  restful_delivery($var, 'format');
}

/**
 * Returns data in JSON format not using data preparation in the formatter
 * plugin.
 *
 * @param $var
 *   (optional) If set, the variable will be converted to JSON and output.
 *
 * @see restful_menu_process_callback()
 */
function restful_unprepared_delivery($var = NULL) {
  restful_delivery($var, 'render');
}

/**
 * Convert a menu status response to a valid JSON.
 *
 * @param int $var
 *   The integer value of the menu status, passed by reference.
 */
function _restful_get_data_from_menu_status(&$var) {
  switch ($var) {
    case MENU_NOT_FOUND:
      $class_name = '\Drupal\restful\Exception\NotFoundException';
      $message = 'Invalid URL path.';
      break;

    case MENU_ACCESS_DENIED:
      $class_name = '\Drupal\restful\Exception\ForbiddenException';
      $message = 'Access denied.';
      break;

    case MENU_SITE_OFFLINE:
      $class_name = '\Drupal\restful\Exception\ServiceUnavailable';
      $message = 'Site is offline.';
      break;
  }

  $e = new $class_name($message);

  $var = array(
    'type' => $e->getType(),
    'title' => $e->getMessage(),
    'status' => $e->getCode(),
    'detail' => $e->getDescription(),
  );

  if ($instance = $e->getInstance()) {
    $var['instance'] = $instance;
  }

  if ($errors = $e->getFieldErrors()) {
    $var['errors'] = $errors;
  }
}

/**
 * Implements hook_page_delivery_callback_alter().
 *
 * Hijack api/* to be under RESTful. We make sure that any call to api/* pages
 * that isn't valid, will still return with a well formatted error, instead of
 * a 404 HTML page.
 */
function restful_page_delivery_callback_alter(&$callback) {
  if (!variable_get('restful_hijack_api_pages', TRUE)) {
    return;
  }

  $base_path = variable_get('restful_hook_menu_base_path', 'api');

  if (strpos($_GET['q'], $base_path . '/') !== 0 && $_GET['q'] != $base_path) {
    // Page doesn't start with the base path (e.g. "api" or "api/").
    return;
  }

  if (menu_get_item()) {
    // Path is valid (i.e. not 404).
    return;
  }

  $callback = 'restful_deliver_menu_not_found';
}

/**
 * Delivers a not found (404) error.
 */
function restful_deliver_menu_not_found($page_callback_result) {
  restful_delivery(MENU_NOT_FOUND);
}

/**
 * Implements hook_cron().
 */
function restful_cron() {
  \Drupal\restful\RateLimit\RateLimitManager::deleteExpired();
}

/**
 * Page callback: returns a session token for the currently active user.
 */
function restful_csrf_session_token() {
  return array('X-CSRF-Token' => drupal_get_token(\Drupal\restful\Plugin\authentication\Authentication::TOKEN_VALUE));
}

/**
 * Element validate \DateTime format function.
 */
function restful_date_time_format_element_validate($element, &$form_state) {
  $value = $element['#value'];
  try {
    new \DateInterval($value);
  }
  catch (\Exception $e) {
    form_error($element, t('%name must be compatible with the !link.', array(
      '%name' => $element['#title'],
      '!link' => l(t('\DateInterval format'), 'http://php.net/manual/en/class.dateinterval.php'),
    )));
  }
}

/**
 * Implements hook_restful_resource_alter().
 */
function restful_restful_resource_alter(ResourceInterface &$resource) {
  $plugin_definition = $resource->getPluginDefinition();
  // Check for the render cache configuration.
  if (!empty($plugin_definition['renderCache']) && !empty($plugin_definition['renderCache']['render'])) {
    $resource = new CachedResource($resource);
  }
  // Check for the rate limit configuration.
  if (!empty($plugin_definition['rateLimit'])) {
    $resource = new RateLimitedResource($resource);
  }

  // Disable the Files Upload resource based on the settings variable.
  if ($resource->getResourceMachineName() == 'files_upload' && variable_get('restful_file_upload', FALSE)) {
    $resource->disable();
  }
}
